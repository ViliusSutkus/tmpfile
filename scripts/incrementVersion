#!/usr/bin/env perl
use warnings;
use strict;

use Getopt::Long;
use Cwd 'abs_path';
use File::Basename;

my $upMajor; my $upMinor; my $upPatch; my $isRelease;
GetOptions(major => \$upMajor, minor => \$upMinor, patch => \$upPatch, release => \$isRelease);

###########################################################################################
### Config ### Config ### Config ### Config ### Config ### Config ### Config ### Config ###
###########################################################################################

my @versionSourceFile = ('build.gradle', qr/^version = '(\d+\.\d+\.\d+)'$/);
my @versionCodeSourceFile = ('tmpfile/build.gradle', qr/^\s+versionCode (\d+)$/);

# Variables available (Don't expand them here):
# $oldVersion, $oldVersionCode - (released),
# $newVersion, $newVersionCode - (unreleased, to be used for upcoming dev builds)
my @filesToUpdate = (
    ['build.gradle', 's/^(version\s*=\s*[\'"])$oldVersion([\'"])$/$1$newVersion$2/'],
    ['tmpfile/build.gradle', 's/^(\s+versionCode\s+)$oldVersionCode$/$1$newVersionCode/']
);

# A released version number needs to be shown in README.md and sample app
my @filesToUpdateOnRelease = (
    ['README.md', 's/^(\s+implementation\s+[\'"]com.viliussutkus89\:tmpfile-android\:)[\d\.]+([\'"])$/$1$oldVersion$2/'],
    ['sampleapp/app/build.gradle',
        's/^(\s+versionName\s+[\'"])[\d\.]+([\'"])$/$1$oldVersion$2/',
        's/^(\s+versionCode\s+)\d+$/$1$oldVersionCode/',
        's/^(\s+implementation\s+[\'"]com\.viliussutkus89\:tmpfile-android\:)[\d\.]+([\'"])$/$1$oldVersion$2/'],
);

sub versionIncrementer {
    my $versionString = shift;
    my $versionCode = shift;
    my ($major, $minor, $patch_) = $versionString =~ /(\d)\.(\d)\.(\d)/;
    if (defined $upMajor) {
        $major++;
        $minor = 0;
        $patch_ = 0;
        $versionCode += 100;
    } elsif (defined $upMinor) {
        $minor++;
        $patch_ = 0;
        $versionCode += 10;
    } elsif (defined $upPatch) {
        $patch_++;
        $versionCode++;
    } else {
        die("Incorrect usage! Call ${0} either with --major, --minor or a --patch argument!");
    }
    return ("${major}.${minor}.${patch_}", $versionCode);
}
###########################################################################################
### ~Config~ # ~Config~ # ~Config~ # ~Config~ # ~Config~ # ~Config~ # ~Config~ # ~Config~ #
###########################################################################################

sub parseFile {
    my $inputFile = (dirname dirname Cwd::abs_path $0) . '/' . shift;
    my $searchExpression = shift;

    open(FH, '<', $inputFile) or die "$! : $inputFile";
    while(<FH>) {
        my @matches = $_ =~ $searchExpression;
        if (@matches) {
            close(FH);
            return $matches[0];
        }
    }
    die("Failed to parse file $inputFile");
}

my $oldVersion = parseFile(@versionSourceFile);
my $oldVersionCode = parseFile(@versionCodeSourceFile);
my ($newVersion, $newVersionCode) = versionIncrementer($oldVersion, $oldVersionCode);

print "oldVersion:$oldVersion, oldVersionCode: $oldVersionCode\n";
print "newVersion:$newVersion, newVersionCode: $newVersionCode\n";

sub updateFile {
    my $workFile = (dirname dirname Cwd::abs_path $0) . '/' . shift;
    my $origFile = $workFile . '.orig';
    my @updateExpressions = @_;

    open(FH_INPUT, '<', $workFile) or die "$! : $workFile";
    rename($workFile, $origFile);
    open(FH_OUTPUT, '>', $workFile) or die "$! : $workFile";
    while(<FH_INPUT>) {
        foreach my $expr (@updateExpressions) {
            eval $expr;
        }
        print FH_OUTPUT $_;
    }
    close(FH_OUTPUT);
    close(FH_INPUT);
    unlink($origFile);
}

foreach my $file (@filesToUpdate) {
    updateFile(@$file);
}
if (defined $isRelease) {
    foreach my $file (@filesToUpdateOnRelease) {
        updateFile(@$file);
    }
}
